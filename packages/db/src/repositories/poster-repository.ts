/**
 * Poster Repository
 *
 * Handles all DynamoDB operations for posters.
 */

import { PutCommand, QueryCommand } from '@aws-sdk/lib-dynamodb';
import type { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';
import { TABLE_NAME } from '../config.js';
import type { Poster, PosterItem, CreatePosterInput } from '../entities/poster.js';

// Default limit for paginated poster queries
// Balances data retrieval size with DynamoDB read capacity
const DEFAULT_POSTER_QUERY_LIMIT = 50;

export class PosterRepository {
  constructor(private readonly client: DynamoDBDocumentClient) {}

  /**
   * Create a new poster.
   *
   * Uses conditional expression to prevent overwrites - if a poster with the
   * same PK/SK already exists, the operation throws ConditionalCheckFailedException.
   * Since SK includes timestamp, duplicate keys are extremely unlikely in practice.
   *
   * @param input - Poster data including posterId (generated by caller)
   * @returns The created poster entity
   * @throws ConditionalCheckFailedException if exact PK/SK combination already exists
   */
  async create(input: CreatePosterInput): Promise<Poster> {
    const now = new Date().toISOString();

    const item: PosterItem = {
      PK: `USER#${input.userId}`,
      SK: `POSTER#${now}#${input.posterId}`,
      entityType: 'POSTER',
      posterId: input.posterId,
      userId: input.userId,
      templateId: input.templateId,
      status: 'completed',
      athleteName: input.athleteName,
      teamName: input.teamName,
      beltRank: input.beltRank,
      tournamentName: input.tournamentName,
      tournamentDate: input.tournamentDate,
      tournamentLocation: input.tournamentLocation,
      achievement: input.achievement,
      imageKey: input.imageKey,
      thumbnailKey: input.thumbnailKey,
      uploadKey: input.uploadKey,
      createdAt: now,
      updatedAt: now,
    };

    await this.client.send(
      new PutCommand({
        TableName: TABLE_NAME,
        Item: item,
        // Prevent duplicate writes - only create if item doesn't exist
        ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
      })
    );

    return this.toEntity(item);
  }

  /**
   * Get all posters for a user (newest first)
   */
  async getByUserId(userId: string, limit = DEFAULT_POSTER_QUERY_LIMIT): Promise<Poster[]> {
    const result = await this.client.send(
      new QueryCommand({
        TableName: TABLE_NAME,
        KeyConditionExpression: 'PK = :pk AND begins_with(SK, :sk)',
        ExpressionAttributeValues: {
          ':pk': `USER#${userId}`,
          ':sk': 'POSTER#',
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
      })
    );

    return (result.Items || []).map((item) => this.toEntity(item as PosterItem));
  }

  /**
   * Count posters for a user in the current month
   */
  async countForCurrentMonth(userId: string): Promise<number> {
    const startOfMonth = new Date();
    startOfMonth.setUTCDate(1);
    startOfMonth.setUTCHours(0, 0, 0, 0);

    const result = await this.client.send(
      new QueryCommand({
        TableName: TABLE_NAME,
        KeyConditionExpression: 'PK = :pk AND SK >= :sk',
        FilterExpression: 'entityType = :entityType',
        ExpressionAttributeValues: {
          ':pk': `USER#${userId}`,
          ':sk': `POSTER#${startOfMonth.toISOString()}`,
          ':entityType': 'POSTER',
        },
        Select: 'COUNT',
      })
    );

    return result.Count || 0;
  }

  private toEntity(item: PosterItem): Poster {
    return {
      posterId: item.posterId,
      userId: item.userId,
      templateId: item.templateId,
      status: item.status,
      athleteName: item.athleteName,
      teamName: item.teamName,
      beltRank: item.beltRank,
      tournamentName: item.tournamentName,
      tournamentDate: item.tournamentDate,
      tournamentLocation: item.tournamentLocation,
      achievement: item.achievement,
      imageKey: item.imageKey,
      thumbnailKey: item.thumbnailKey,
      uploadKey: item.uploadKey,
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
    };
  }
}
