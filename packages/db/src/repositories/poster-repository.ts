/**
 * Poster Repository
 *
 * Handles all DynamoDB operations for posters.
 */

import { PutCommand, QueryCommand } from '@aws-sdk/lib-dynamodb';
import type { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';
import { TABLE_NAME } from '../config.js';
import type {
  Poster,
  PosterItem,
  CreatePosterInput,
  PaginatedPostersOptions,
  PaginatedPostersResult,
} from '../entities/poster.js';

// Default limit for paginated poster queries
// Balances data retrieval size with DynamoDB read capacity
const DEFAULT_POSTER_QUERY_LIMIT = 50;

// Pagination constants
const DEFAULT_PAGINATED_LIMIT = 20;
const MAX_PAGINATED_LIMIT = 50;

export class PosterRepository {
  constructor(private readonly client: DynamoDBDocumentClient) {}

  /**
   * Create a new poster.
   *
   * Uses conditional expression to prevent overwrites - if a poster with the
   * same PK/SK already exists, the operation throws ConditionalCheckFailedException.
   * Since SK includes timestamp, duplicate keys are extremely unlikely in practice.
   *
   * @param input - Poster data including posterId (generated by caller)
   * @returns The created poster entity
   * @throws ConditionalCheckFailedException if exact PK/SK combination already exists
   */
  async create(input: CreatePosterInput): Promise<Poster> {
    const now = new Date().toISOString();

    const item: PosterItem = {
      PK: `USER#${input.userId}`,
      SK: `POSTER#${now}#${input.posterId}`,
      entityType: 'POSTER',
      posterId: input.posterId,
      userId: input.userId,
      templateId: input.templateId,
      status: 'completed',
      athleteName: input.athleteName,
      teamName: input.teamName,
      beltRank: input.beltRank,
      tournamentName: input.tournamentName,
      tournamentDate: input.tournamentDate,
      tournamentLocation: input.tournamentLocation,
      achievement: input.achievement,
      imageKey: input.imageKey,
      thumbnailKey: input.thumbnailKey,
      uploadKey: input.uploadKey,
      createdAt: now,
      updatedAt: now,
    };

    await this.client.send(
      new PutCommand({
        TableName: TABLE_NAME,
        Item: item,
        // Prevent duplicate writes - only create if item doesn't exist
        ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)',
      })
    );

    return this.toEntity(item);
  }

  /**
   * Get all posters for a user (newest first)
   */
  async getByUserId(userId: string, limit = DEFAULT_POSTER_QUERY_LIMIT): Promise<Poster[]> {
    const result = await this.client.send(
      new QueryCommand({
        TableName: TABLE_NAME,
        KeyConditionExpression: 'PK = :pk AND begins_with(SK, :sk)',
        ExpressionAttributeValues: {
          ':pk': `USER#${userId}`,
          ':sk': 'POSTER#',
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
      })
    );

    return (result.Items || []).map((item) => this.toEntity(item as PosterItem));
  }

  /**
   * Get paginated posters for a user (newest first)
   *
   * Uses cursor-based pagination with Base64-encoded SK.
   * Optionally filters by belt rank using DynamoDB FilterExpression.
   */
  async getByUserIdPaginated(
    userId: string,
    options: PaginatedPostersOptions = {}
  ): Promise<PaginatedPostersResult> {
    const limit = Math.min(
      options.limit || DEFAULT_PAGINATED_LIMIT,
      MAX_PAGINATED_LIMIT
    );

    // Build expression attribute values
    const expressionValues: Record<string, string> = {
      ':pk': `USER#${userId}`,
      ':sk': 'POSTER#',
    };

    // Build optional filter expression for belt rank
    let filterExpression: string | undefined;
    if (options.beltRank) {
      filterExpression = 'beltRank = :beltRank';
      expressionValues[':beltRank'] = options.beltRank;
    }

    // Decode cursor to ExclusiveStartKey if provided
    let exclusiveStartKey: Record<string, string> | undefined;
    if (options.cursor) {
      const decodedSK = Buffer.from(options.cursor, 'base64').toString('utf-8');
      exclusiveStartKey = {
        PK: `USER#${userId}`,
        SK: decodedSK,
      };
    }

    const result = await this.client.send(
      new QueryCommand({
        TableName: TABLE_NAME,
        KeyConditionExpression: 'PK = :pk AND begins_with(SK, :sk)',
        ExpressionAttributeValues: expressionValues,
        FilterExpression: filterExpression,
        ExclusiveStartKey: exclusiveStartKey,
        ScanIndexForward: false, // Newest first
        Limit: limit + 1, // Fetch one extra to detect hasMore
      })
    );

    const items = (result.Items || []) as PosterItem[];

    // Check if there are more items
    const hasMore = items.length > limit;
    const returnItems = hasMore ? items.slice(0, limit) : items;

    // Encode next cursor from last returned item
    let nextCursor: string | null = null;
    if (hasMore && returnItems.length > 0) {
      const lastItem = returnItems[returnItems.length - 1];
      nextCursor = Buffer.from(lastItem.SK).toString('base64');
    }

    return {
      items: returnItems.map((item) => this.toEntity(item)),
      nextCursor,
    };
  }

  /**
   * Count posters for a user in the current month
   */
  async countForCurrentMonth(userId: string): Promise<number> {
    const startOfMonth = new Date();
    startOfMonth.setUTCDate(1);
    startOfMonth.setUTCHours(0, 0, 0, 0);

    const result = await this.client.send(
      new QueryCommand({
        TableName: TABLE_NAME,
        KeyConditionExpression: 'PK = :pk AND SK >= :sk',
        FilterExpression: 'entityType = :entityType',
        ExpressionAttributeValues: {
          ':pk': `USER#${userId}`,
          ':sk': `POSTER#${startOfMonth.toISOString()}`,
          ':entityType': 'POSTER',
        },
        Select: 'COUNT',
      })
    );

    return result.Count || 0;
  }

  private toEntity(item: PosterItem): Poster {
    return {
      posterId: item.posterId,
      userId: item.userId,
      templateId: item.templateId,
      status: item.status,
      athleteName: item.athleteName,
      teamName: item.teamName,
      beltRank: item.beltRank,
      tournamentName: item.tournamentName,
      tournamentDate: item.tournamentDate,
      tournamentLocation: item.tournamentLocation,
      achievement: item.achievement,
      imageKey: item.imageKey,
      thumbnailKey: item.thumbnailKey,
      uploadKey: item.uploadKey,
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
    };
  }
}
